/*
Написать шаблон функции, выполняющей указанные в вариа-тивной части задания действия.
Написать программу тестирования шаблонных функций, созданных на основе этого шаблона, с
аргументами указанных типов. Разработать шаблон класса, опи-сывающий указанный в вариативной
части задания абстрактный тип данных, и написать программу тестирования объектов двух59
шаблонных классов. Выбор тестируемого метода должен осу-ществляться с помощью меню. Это
задание может быть выполнено на трех уровнях сложности:
1) низкий. Указанный АТД можно реализовать любым удобным способом;
2) средний. Заданный АТД реализовать с помощью указанной структуры хранения;
3) повышенный. Создать требуемый АТД с помощью двух структур хранения: векторной и
списковой, реализацию оформить в виде шаблонов классов с единым интерфейсом*/

/*Вариант 13
Типы аргументов unsigned int и float.
1. Перестановка элементов массива в обратном порядке.
2. АТД Дек с ограниченным входом. Структура хранения – связанный список*/


#include "pch.h"
#include <iostream>
#include <deque>
using namespace std;
int main()
{
	setlocale(LC_ALL, "Russian");
	int dequeSize;
	char selector;
	cout << "Введите размер дека:" << endl;
	cin >> dequeSize;

	cout << "Выберите тип данных для дека: " << endl;
	cout << "1. Дек для unsigned int" << endl;
	cout << "2. Дек для float" << endl;

	cin >> selector;

	float inputFloat;
	unsigned int inputUnsigned;
	//после выбора меню пользователем происходит добавление в дек выбранного числа элементов и их извлечение 
	switch (selector)
	{
	case '1':
	{
		deque<unsigned int> dequeUnsigned;
		
		cout << "Добавление элементов в дек " << endl;

		for (int i = 0; i < dequeSize; i++)
		{
			cout << "Добавление элемента с индексом " << i << " :";
			cin >> inputUnsigned;
			dequeUnsigned.push_back(inputUnsigned);
		}

		cout << "Извлечение из дека :" << endl;
		auto begin = dequeUnsigned.begin();//итератор, указывающий на начало дека
		auto end = dequeUnsigned.end();//итератор, указывающий на конец дека
		while (begin!=end)//пока конец не равен началу, получаем значение элементов дека
		{
			cout << *begin << " ";
			begin++;
		}

		break;
	}
	case '2':
	{
		deque<float> dequeFloat;

		cout << "Добавление элементов в дек " << endl;

		for (int i = 0; i < dequeSize; i++)
		{
			cout << "Добавление элемента с индексом " << i << " :";
			cin >> inputFloat;
			dequeFloat.push_back(inputFloat);
		}

		cout << "Извлечение из дека :" << endl;

		auto begin = dequeFloat.begin();//итератор, указывающий на начало дека

		auto end = dequeFloat.end();//итератор, указывающий на конец дека
		while (begin != end)//пока конец не равен началу, получаем значение элементов дека
		{
			cout << *begin << " ";
			begin++;
		}

		break;
	}


	}

	system("pause");
}